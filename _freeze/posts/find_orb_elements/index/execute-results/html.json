{
  "hash": "9c00e78df6209313048a038aa142022e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"How to find orbital elements?\"\ndescription: \"In this post, we write a Python programme to to find orbital elements.\"\nauthor: \"Madhukara S Putty\"\ndate: \"2025-06-23\"\ncategories: [orbital mechanics, scientific computing]\n---\n\n::: {#5b94e2bf .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nmu = 398600.4418\nK = np.array([0, 0, 1])\n\ndef magnitude(x):\n    return np.linalg.norm(x)\n\ndef radial_velocity(r, v):\n    v_rad = np.dot(r, v)/magnitude(r)\n    return v_rad\n\ndef ang_mom(r, v):\n    h_vec = np.cross(r, v)\n    return h_vec\n\ndef inclination(h_vec):\n    i = np.degrees(np.arccos(h_vec[2]/magnitude(h_vec)))\n    return i\n\n#Node line\ndef node_line(K, h_vec):\n    N_vec = np.cross(K, h_vec)\n    return N_vec\n\ndef right_ascension_of_ascending_node(N_vec):\n    if N_vec[1] >= 0:\n        RAAN = np.degrees(np.arccos(N_vec[0]/magnitude(N_vec)))\n    if N_vec[1] < 0:\n        RAAN = 360 - np.degrees(np.arccos(N_vec[0]/magnitude(N_vec)))\n    return RAAN\n\ndef eccentricity(r, v, mu):\n    h_vec = ang_mom(r, v)\n    e_vec = (np.cross(v, h_vec) / mu) - (r / magnitude(r))\n    return e_vec\n\ndef argument_of_perigee(N_vec, e_vec):\n    if e_vec[2] >= 0:\n        omega = np.degrees(np.arccos(np.dot(N_vec, e_vec)/(magnitude(N_vec)*magnitude(e_vec))))\n    if e_vec[2] < 0:\n        omega = 360 - np.degrees(np.arccos(np.dot(N_vec, e_vec)/(magnitude(N_vec)*magnitude(e_vec))))\n    return omega\n\ndef true_anomaly(e_vec, r, v):\n    v_rad = radial_velocity(r, v)\n    if v_rad >= 0:\n        theta = np.degrees(np.arccos(np.dot(e_vec, r)/(magnitude(e_vec)*magnitude(r))))\n    if v_rad < 0:\n        theta = 360 - np.degrees(np.arccos(np.dot(e_vec, r)/(magnitude(e_vec)*magnitude(r))))\n    return theta\n\ndef main():\n    r = np.array([-6045, -3490, 2500])\n    v = np.array([-3.457, 6.618, 2.533])\n    v_rad = radial_velocity(r, v)\n    h_vec = ang_mom(r=r, v=v)\n    h = magnitude(h_vec)\n    i = inclination(h_vec=h_vec)\n    N_vec = node_line(K, h_vec)\n    RAAN = right_ascension_of_ascending_node(N_vec)\n    e_vec = eccentricity(r, v, mu)\n    e = magnitude(e_vec)\n    omega = argument_of_perigee(N_vec, e_vec)\n    theta = true_anomaly(e_vec, r, v)\n    \n    print(\"h = {0:5.2f} \".format(h))\n    print(\"Inclination = {0:5.2f} deg\".format(i))\n    print(\"RAAN = {0:5.2f} deg\".format(RAAN))\n    print(\"e = {0:5.2f} \".format(e))\n    print(\"Omega = {0:5.2f} deg\".format(omega))\n    print(\"True anomaly = {0:5.2f} deg\".format(theta))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh = 58311.67 \nInclination = 153.25 deg\nRAAN = 255.28 deg\ne =  0.17 \nOmega = 20.07 deg\nTrue anomaly = 28.45 deg\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}